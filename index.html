<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Algorithmic Devious Work</title>
  <style>
    /* ====== Reset & Theme ====== */
    :root{
      --bg:#0f1220;           /* deep navy */
      --panel:#171a2b;        /* card background */
      --panel-2:#101427;      /* alt card */
      --muted:#8b90a6;        /* muted text */
      --text:#e8ebff;         /* primary text */
      --accent:#6ab3ff;       /* primary accent */
      --accent-2:#66ffcc;     /* secondary accent */
      --danger:#ff6b6b;
      --warn:#ffb86b;
      --ok:#5af79f;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --radius-lg: 22px;
      --gap: 14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      color:var(--text); background: radial-gradient(1200px 600px at 10% -10%, #1a1f3a 0%, transparent 60%),
                         radial-gradient(800px 400px at 100% 0%, #0e162f 0%, transparent 70%),
                         var(--bg);
    }
    button,input,select{font:inherit; color:inherit}

    /* ===== App Layout ===== */
    .app{
      display:grid; grid-template-rows:auto 1fr auto; min-height:100vh; gap:var(--gap);
    }
    header{
      position:sticky; top:0; z-index:5; padding:10px clamp(10px,2vw,24px);
      background:linear-gradient(180deg, rgba(15,18,32,.95), rgba(15,18,32,.65));
      backdrop-filter:saturate(1.4) blur(6px);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .toolbar{
      display:grid; grid-template-columns: 1fr auto; gap:var(--gap);
      align-items:center;
    }
    .left, .right{ display:flex; flex-wrap:wrap; gap:var(--gap); align-items:center; }

    .brand{ display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.2px; }
    .brand .logo{ width:38px; height:38px; border-radius:12px; background:linear-gradient(135deg,var(--accent),var(--accent-2)); box-shadow:var(--shadow); display:grid; place-items:center; font-weight:900; color:#0b1320 }

    .select, .control, .toggle, .btn{ background:var(--panel); border:1px solid rgba(255,255,255,.06); border-radius:var(--radius); padding:10px 12px; box-shadow:var(--shadow); }
    .select select{ background:transparent; border:none; outline:none; appearance:none; min-width:170px; }
    .select label{ font-size:12px; color:var(--muted); display:block; margin-bottom:4px; }

    .control{ display:grid; grid-template-columns: 1fr; min-width:190px; }
    .control label{ font-size:12px; color:var(--muted); margin-bottom:6px; }
    .control input[type="range"]{ width:100% }

    .btn{ cursor:pointer; user-select:none; transition:transform .08s ease, box-shadow .2s ease, background .2s ease; }
    .btn:hover{ transform:translateY(-1px) }
    .btn:active{ transform:translateY(0) scale(.98) }
    .btn-row{ display:flex; gap:10px }
    .btn.primary{ background:linear-gradient(135deg, rgba(106,179,255,.15), rgba(102,255,204,.12)); border-color: rgba(102,255,204,.25); }
    .btn.warn{ background:linear-gradient(135deg, rgba(255,184,107,.1), rgba(255,107,107,.1)); border-color: rgba(255,184,107,.25) }

    .toggle{ display:flex; align-items:center; gap:10px; cursor:pointer; }
    .toggle input{ accent-color:var(--accent-2) }

    main{ padding: 0 clamp(10px,2vw,24px) 24px; }

    .stage{ display:grid; grid-template-columns: 1fr; gap:var(--gap); }
    .canvases{ display:grid; grid-template-columns: 1fr; gap:var(--gap); }
    .canvas-card{ background:var(--panel-2); border:1px solid rgba(255,255,255,.06); border-radius:var(--radius-lg); padding:10px; position:relative; box-shadow:var(--shadow); overflow:hidden; }
    .canvas-card h3{ margin:10px 12px; color:var(--muted); font-weight:600 }
    canvas{ width:100%; height:420px; display:block; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.08)); border-radius:12px }

    .stats{
      display:grid; grid-template-columns: repeat(auto-fit,minmax(190px,1fr)); gap:var(--gap);
    }
    .stat{ background:var(--panel); border:1px solid rgba(255,255,255,.06); border-radius:var(--radius); padding:12px }
    .stat .k{ font-size:12px; color:var(--muted) }
    .stat .v{ font-size:20px; font-weight:700; letter-spacing:.3px }

    footer{ color:var(--muted); font-size:12px; padding: 6px 16px 20px; text-align:center; }

    /* Battle mode layout */
    .battle .canvases{ grid-template-columns: 1fr 1fr }

    /* Small screens */
    @media (max-width: 920px){
      .toolbar{ grid-template-columns: 1fr; }
      .right{ justify-content:space-between }
      canvas{ height:340px }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="toolbar">
        <div class="left">
          <div class="brand"><div class="logo">AD</div> Algorithmic Devious Work</div>

          <div class="select">
            <label>Category</label>
            <select id="category">
              <option value="sort">Searching & Sorting</option>
              <option value="graph">Graph Algorithms</option>
              <option value="ml">Machine Learning</option>
            </select>
          </div>

          <div class="select">
            <label>Algorithm</label>
            <select id="algorithm"></select>
          </div>

          <div class="control" title="Speed">
            <label>Speed</label>
            <input id="speed" type="range" min="0.1" max="4" value="1" step="0.1" />
          </div>

          <div class="control" title="Data Size">
            <label>Data Size</label>
            <input id="size" type="range" min="10" max="200" value="64" step="1" />
          </div>
        </div>

        <div class="right">
          <div class="btn-row">
            <button class="btn primary" id="play">▶ Play</button>
            <button class="btn" id="pause">⏸ Pause</button>
            <button class="btn warn" id="reset">⟲ Reset</button>
          </div>
          <label class="toggle" title="Run two algorithms side-by-side on same data">
            <input id="battle" type="checkbox" /> Battle Mode
          </label>
        </div>
      </div>
    </header>

    <main>
      <section class="stage" id="stage">
        <div class="canvases" id="canvases">
          <div class="canvas-card"><h3 id="titleA">Visualizer</h3><canvas id="canvasA" width="1280" height="480"></canvas></div>
          <!-- canvas B dynamically toggled for battle mode -->
        </div>

        <div class="stats" id="stats">
          <div class="stat"><div class="k">Status</div><div class="v" id="status">Idle</div></div>
          <div class="stat"><div class="k">Steps</div><div class="v" id="steps">0</div></div>
          <div class="stat"><div class="k">Comparisons / Visits</div><div class="v" id="comps">0</div></div>
          <div class="stat"><div class="k">Elapsed</div><div class="v" id="elapsed">0.0s</div></div>
        </div>
      </section>
    </main>

    <footer>© <span id="year"></span> Algorithmic Devious Work • Smooth visuals, modular core, and a tiny dash of sonic sparkle.</footer>
  </div>

  <script>
  // =============================================================
  // Algorithmic Devious Work — Single-file app
  // Architecture: Registry + Runner + Renderers + SFX
  // =============================================================

  // ---------- Utilities ----------
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const ease = t=>t<.5? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; // cubic
  const now  = ()=>performance.now();

  // RNG helper (deterministic with seed for battle fairness)
  function mulberry32(a){
    return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; };
  }

  // Tiny event bus
  const E = (()=>{ const m={}; return { on:(k,f)=>(m[k]??=[]).push(f), emit:(k,...a)=>(m[k]||[]).forEach(fn=>fn(...a)) }})()

  // ---------- Sound FX (WebAudio, tiny & satisfying) ----------
  const Audio = (()=>{
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const master = ctx.createGain(); master.gain.value=.15; master.connect(ctx.destination);
    function blip(type='sine', f=440, dur=.07){
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type=type; o.frequency.setValueAtTime(f, ctx.currentTime);
      g.gain.setValueAtTime(.0001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(.5, ctx.currentTime+.01);
      g.gain.exponentialRampToValueAtTime(.0001, ctx.currentTime+dur);
      o.connect(g); g.connect(master); o.start(); o.stop(ctx.currentTime+dur);
    }
    return { swap:()=>blip('triangle', 520), visit:()=>blip('sine', 320,.05), done:()=>blip('sawtooth', 660,.2) };
  })();

  // ---------- Data generators ----------
  const Data = {
    array(n=64, rng=Math.random){ return Array.from({length:n},()=>Math.floor(rng()*100)+1); },
    graph(grid=20, rng=Math.random){ // grid graph for pathfinding
      const cells=[]; for(let y=0;y<grid;y++) for(let x=0;x<grid;x++) cells.push({x,y, w:1 + Math.floor(rng()*9)});
      return { grid, cells };
    },
    points(n=120, rng=Math.random){ return Array.from({length:n},()=>({x:rng(), y:rng()})); }
  };

  // ---------- Algorithm Registry / Interface ----------
  // An algorithm is an object with: id, name, category, create(state)
  // create(state) returns a controller with: init(seed,data,size), step(dt), draw(ctx, rect), finished:boolean, stats

  const REGISTRY = [];
  function register(a){ REGISTRY.push(a); }
  const Algorithms = {
    listBy(cat){ return REGISTRY.filter(a=>a.category===cat); },
    find(id){ return REGISTRY.find(a=>a.id===id); }
  };

  // ---------- Render helpers ----------
  function clear(ctx, w, h){
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'rgba(255,255,255,.02)');
    g.addColorStop(1,'rgba(0,0,0,.12)');
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  }

  // Bars renderer for arrays
  function drawBars(ctx, arr, highlights={}, smoothY=true){
    const {width:w, height:h} = ctx.canvas;
    const n = arr.length; const barW = w/n;
    const max = Math.max(...arr, 100);
    ctx.lineWidth = Math.max(1, barW-2);
    ctx.lineCap = 'round';
    for(let i=0;i<n;i++){
      const v = arr[i]/max; const y = v*h; const x = i*barW + barW/2;
      const t = highlights[i]?.t ?? 0; // animate highlight
      const color = highlights[i]?.color || `hsl(${200+120*v}, 80%, ${40+20*v}%)`;
      ctx.strokeStyle=color; ctx.globalAlpha = lerp(.65,1,ease(clamp(t,0,1)));
      ctx.beginPath(); ctx.moveTo(x, h-2); ctx.lineTo(x, h - y - 2); ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Grid renderer for graph/pathfinding (weighted)
  function drawGrid(ctx, grid, path=set){
    const {width:w, height:h} = ctx.canvas; const n=grid.grid; const cell = Math.min(w/n, h/n);
    for(const c of grid.cells){
      const x=c.x*cell, y=c.y*cell; const weight = c.w;
      ctx.fillStyle = `hsl(${200-10*weight},70%,${28+weight*4}%)`;
      ctx.fillRect(x,y,cell-1,cell-1);
    }
    if(path && path.size){
      ctx.fillStyle = '#fff';
      for(const key of path){ const [x,y]=key.split(',').map(Number); ctx.fillRect(x*cell+cell*.25,y*cell+cell*.25,cell*.5,cell*.5); }
    }
  }

  // Scatter renderer for ML
  function drawPoints(ctx, pts, centers){
    const {width:w, height:h}=ctx.canvas;
    for(const p of pts){ ctx.beginPath(); ctx.arc(p.x*w, p.y*h, 4, 0, Math.PI*2); ctx.fillStyle=p.c || 'rgba(255,255,255,.8)'; ctx.fill(); }
    if(centers){
      ctx.lineWidth=3;
      for(const c of centers){ ctx.beginPath(); ctx.arc(c.x*w, c.y*h, 8, 0, Math.PI*2); ctx.strokeStyle=c.c || '#6ab3ff'; ctx.stroke(); }
    }
  }

  // ---------- Sorting algorithms (multiple) ----------
  function makeArrayController(name, coreStep){
    return {
      id: name.toLowerCase().replace(/\s+/g,'-'), name, category:'sort',
      create(){
        let arr=[], highlights={}, i=0, j=0, stack=[], swaps=0, comps=0, done=false, seed=0, rng=Math.random;
        return {
          init(_seed, _data, size){ seed=_seed; rng=mulberry32(seed); arr = Data.array(size, rng); i=0; j=0; stack=[]; swaps=0; comps=0; done=false; highlights={}; },
          step(dt){ if(done) return; const r = coreStep({arr, iRef:()=>i, setI:v=>i=v, jRef:()=>j, setJ:v=>j=v, stack, setDone:v=>done=v, mark:(k,c)=>{highlights[k]={color:c,t:1}}, swapsRef:()=>swaps, setSwaps:v=>swaps=v, compsRef:()=>comps, setComps:v=>comps=v, rng}); if(r==='swap'){ Audio.swap(); } if(r==='visit'){ Audio.visit(); }
            // fade highlights
            for(const k in highlights){ highlights[k].t = (highlights[k].t||1) - dt*1.5; if(highlights[k].t<=0) delete highlights[k]; }
            if(done){ Audio.done(); }
          },
          draw(ctx, rect){ clear(ctx, ctx.canvas.width, ctx.canvas.height); drawBars(ctx, arr, highlights); },
          get finished(){ return done; },
          get stats(){ return { swaps, comps }; }
        }
      }
    }
  }

  // --- Bubble Sort ---
  register( makeArrayController('Bubble Sort', ({arr,iRef,setI,jRef,setJ, setDone, mark, swapsRef,setSwaps, compsRef,setComps})=>{
    let i=iRef(), j=jRef();
    if(i>=arr.length){ setDone(true); return; }
    if(j>=arr.length-1-i){ setJ(0); setI(++i); return; }
    setComps(compsRef()+1); mark(j,'#6ab3ff'); mark(j+1,'#6ab3ff');
    if(arr[j]>arr[j+1]){ [arr[j],arr[j+1]]=[arr[j+1],arr[j]]; setSwaps(swapsRef()+1); setJ(++j); return 'swap'; }
    setJ(++j); return 'visit';
  }));

  // --- Insertion Sort ---
  register( makeArrayController('Insertion Sort', ({arr,iRef,setI, jRef,setJ, setDone, mark, swapsRef,setSwaps, compsRef,setComps})=>{
    let i=iRef(), j=jRef();
    if(i>=arr.length){ setDone(true); return; }
    if(j<=0){ setI(++i); setJ(i); return; }
    setComps(compsRef()+1); mark(j,'#6ab3ff'); mark(j-1,'#6ab3ff');
    if(arr[j]<arr[j-1]){ [arr[j],arr[j-1]]=[arr[j-1],arr[j]]; setSwaps(swapsRef()+1); setJ(--j); return 'swap'; }
    setI(++i); setJ(i); return 'visit';
  }));

  // --- Selection Sort ---
  register( makeArrayController('Selection Sort', ({arr,iRef,setI, jRef,setJ, setDone, mark, swapsRef,setSwaps, compsRef,setComps})=>{
    let i=iRef(), j=jRef();
    if(i>=arr.length-1){ setDone(true); return; }
    if(j===0) j=i+1; let min=i;
    for(let k=i+1;k<arr.length;k++){ setComps(compsRef()+1); if(arr[k]<arr[min]) min=k; }
    if(min!==i){ [arr[i],arr[min]]=[arr[min],arr[i]]; setSwaps(swapsRef()+1); }
    setI(++i); setJ(0); return 'swap';
  }));

  // --- Merge Sort (iterative) ---
  register( makeArrayController('Merge Sort', ({arr, stack, setDone, mark, compsRef,setComps})=>{
    if(stack.length===0){ // init segments size 1
      for(let i=1;i<arr.length;i*=2) stack.push(i);
    }
    const width = stack[0]; if(!width){ setDone(true); return; }
    function merge(start, mid, end){
      const tmp=[]; let i=start, j=mid;
      while(i<mid && j<end){ setComps(compsRef()+1); mark(i,'#6ab3ff'); mark(j,'#6ab3ff'); if(arr[i]<=arr[j]) tmp.push(arr[i++]); else tmp.push(arr[j++]); }
      while(i<mid) tmp.push(arr[i++]); while(j<end) tmp.push(arr[j++]);
      for(let k=0;k<tmp.length;k++) arr[start+k]=tmp[k];
    }
    for(let start=0; start<arr.length; start += 2*width){ const mid=Math.min(start+width,arr.length), end=Math.min(start+2*width,arr.length); merge(start,mid,end); }
    stack.shift(); return 'swap';
  }));

  // --- Quick Sort (stack-based) ---
  register( makeArrayController('Quick Sort', ({arr, stack, setDone, mark, swapsRef,setSwaps, compsRef,setComps})=>{
    if(stack.length===0) stack.push([0,arr.length-1]);
    if(stack.length===0){ setDone(true); return; }
    const seg = stack.pop(); if(!seg){ setDone(true); return; }
    const [l0,r0]=seg; let l=l0, r=r0; const p = arr[Math.floor((l+r)/2)];
    while(l<=r){ setComps(compsRef()+1); while(arr[l]<p){ l++; setComps(compsRef()+1); }
      while(arr[r]>p){ r--; setComps(compsRef()+1); }
      if(l<=r){ [arr[l],arr[r]]=[arr[r],arr[l]]; setSwaps(swapsRef()+1); l++; r--; }
    }
    if(l<r0) stack.push([l,r0]); if(l0<r) stack.push([l0,r]); return 'swap';
  }));

  // --- Heap Sort ---
  register( makeArrayController('Heap Sort', ({arr, stack, setDone, mark, swapsRef,setSwaps, compsRef,setComps})=>{
    if(stack.length===0){ // build heap
      const n=arr.length; for(let i=Math.floor(n/2)-1;i>=0;i--){ heapify(n,i);} stack.push(['extract', n-1]);
      function heapify(n,i){ let largest=i; const l=2*i+1, r=2*i+2; if(l<n && (++compsRef, arr[l]>arr[largest])) largest=l; if(r<n && (++compsRef, arr[r]>arr[largest])) largest=r; if(largest!==i){ [arr[i],arr[largest]]=[arr[largest],arr[i]]; setSwaps(swapsRef()+1); heapify(n,largest); } }
    }
    const top = stack.pop(); if(!top){ setDone(true); return; }
    const [mode, i] = top; if(mode==='extract'){
      [arr[0],arr[i]]=[arr[i],arr[0]]; setSwaps(swapsRef()+1);
      heapify(i,0); if(i-1>0) stack.push(['extract', i-1]);
      function heapify(n,i){ let largest=i; const l=2*i+1, r=2*i+2; if(l<n){ setComps(compsRef()+1); if(arr[l]>arr[largest]) largest=l; } if(r<n){ setComps(compsRef()+1); if(arr[r]>arr[largest]) largest=r; } if(largest!==i){ [arr[i],arr[largest]]=[arr[largest],arr[i]]; setSwaps(swapsRef()+1); heapify(n,largest); } }
      return 'swap';
    }
  }));

  // --- Searching: Linear & Binary (visual with target highlight) ---
  register( makeArrayController('Linear Search', ({arr, iRef,setI, setDone, mark, compsRef,setComps, rng})=>{
    if(iRef()===0){ // pick target once
      const targetIndex = Math.floor(rng()*arr.length); const target = arr[targetIndex]; arr.target = target;
    }
    let i=iRef();
    if(i>=arr.length){ setDone(true); return; }
    setComps(compsRef()+1); mark(i, arr[i]===arr.target? '#66ffcc' : '#6ab3ff');
    if(arr[i]===arr.target){ setDone(true); return 'visit'; }
    setI(++i); return 'visit';
  }));

  register( makeArrayController('Binary Search', ({arr, stack, setDone, mark, compsRef,setComps, rng})=>{
    if(!arr.sorted){ arr.sort((a,b)=>a-b); arr.sorted=true; arr.target = arr[Math.floor(rng()*arr.length)]; stack.push([0,arr.length-1]); }
    const seg = stack.pop(); if(!seg){ setDone(true); return; }
    const [l,r]=seg; if(l>r){ setDone(true); return; }
    const m = Math.floor((l+r)/2); setComps(compsRef()+1); mark(m,'#6ab3ff');
    if(arr[m]===arr.target){ setDone(true); return 'visit'; }
    if(arr[m]<arr.target) stack.push([m+1,r]); else stack.push([l,m-1]); return 'visit';
  }));

  // ---------- Graph algorithms ----------
  function key(x,y){ return `${x},${y}`; }

  function graphController(name, stepper){
    return {
      id:name.toLowerCase().replace(/\s+/g,'-'), name, category:'graph',
      create(){
        let grid, frontier=[], visited=new Set(), cameFrom=new Map(), start={x:0,y:0}, goal={x:19,y:19}, done=false, seed=0, rng=Math.random, t=0;
        return {
          init(_seed){ seed=_seed; rng=mulberry32(seed); grid=Data.graph(20, rng); visited.clear(); cameFrom.clear(); frontier.length=0; start={x:0,y:0}; goal={x:grid.grid-1,y:grid.grid-1}; done=false; t=0; stepper.init?.({grid, frontier, visited, cameFrom, start, goal, rng}); },
          step(dt){ if(done) return; t+=dt; const res = stepper.step({grid, frontier, visited, cameFrom, start, goal, rng}); if(res==='visit') Audio.visit(); if(res==='done'){ done=true; Audio.done(); } },
          draw(ctx){ clear(ctx, ctx.canvas.width, ctx.canvas.height); const path = new Set(); if(done){ let cur=goal; while(cur && !(cur.x===start.x && cur.y===start.y)){ path.add(key(cur.x,cur.y)); cur=cameFrom.get(key(cur.x,cur.y)); } }
            drawGrid(ctx, grid, path);
          },
          get finished(){ return done; },
          get stats(){ return { visits: visited.size, cost: pathCost(cameFrom, start, goal, grid) } }
        }
      }
    }
  }

  function pathCost(came, start, goal, grid){ if(!came.size) return 0; let cur=goal, cost=0; while(cur && !(cur.x===start.x && cur.y===start.y)){ const prev=came.get(key(cur.x,cur.y)); if(!prev) break; const cell = grid.cells.find(c=>c.x===cur.x && c.y===cur.y); cost += cell?.w||1; cur=prev; } return cost; }

  // --- BFS ---
  register( graphController('BFS', {
    init({frontier, start, visited}){ frontier.push(start); visited.add(key(start.x,start.y)); },
    step({grid, frontier, visited, cameFrom, goal}){
      if(frontier.length===0) return 'done';
      const cur = frontier.shift(); if(cur.x===goal.x && cur.y===goal.y) return 'done';
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){ const nx=cur.x+dx, ny=cur.y+dy; if(nx<0||ny<0||nx>=grid.grid||ny>=grid.grid) continue; const k=key(nx,ny); if(!visited.has(k)){ visited.add(k); cameFrom.set(k, cur); frontier.push({x:nx,y:ny}); return 'visit'; } }
    }
  }));

  // --- Dijkstra ---
  register( graphController("Dijkstra's", {
    init({frontier, start, visited}){ frontier.push({x:start.x,y:start.y, d:0}); },
    step({grid, frontier, visited, cameFrom, goal}){
      if(frontier.length===0) return 'done';
      // pick min distance (simple O(n))
      let idx=0; for(let i=1;i<frontier.length;i++) if(frontier[i].d<frontier[idx].d) idx=i;
      const cur = frontier.splice(idx,1)[0]; const k0=key(cur.x,cur.y); if(visited.has(k0)) return; visited.add(k0); if(cur.x===goal.x && cur.y===goal.y) return 'done';
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){ const nx=cur.x+dx, ny=cur.y+dy; if(nx<0||ny<0||nx>=grid.grid||ny>=grid.grid) continue; const k=key(nx,ny); if(visited.has(k)) continue; const w = grid.cells.find(c=>c.x===nx&&c.y===ny).w; const nd = cur.d + w; const ex = frontier.find(n=>n.x===nx&&n.y===ny); if(!ex || nd<ex.d){ if(!ex) frontier.push({x:nx,y:ny,d:nd}); else ex.d=nd; cameFrom.set(k, {x:cur.x,y:cur.y}); }
      }
      return 'visit';
    }
  }));

  // --- A* ---
  register( graphController('A* Search', {
    init({frontier, start}){ frontier.push({x:start.x,y:start.y, g:0, f:0}); },
    step({grid, frontier, visited, cameFrom, start, goal}){
      if(frontier.length===0) return 'done';
      let idx=0; for(let i=1;i<frontier.length;i++) if(frontier[i].f<frontier[idx].f) idx=i;
      const cur = frontier.splice(idx,1)[0]; const k0=key(cur.x,cur.y); if(visited.has(k0)) return; visited.add(k0); if(cur.x===goal.x&&cur.y===goal.y) return 'done';
      const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of dirs){ const nx=cur.x+dx, ny=cur.y+dy; if(nx<0||ny<0||nx>=grid.grid||ny>=grid.grid) continue; const w = grid.cells.find(c=>c.x===nx&&c.y===ny).w; const g = cur.g + w; const h = Math.abs(goal.x-nx)+Math.abs(goal.y-ny); const f=g+h; const k=key(nx,ny); const ex=frontier.find(n=>n.x===nx&&n.y===ny); if(!ex || f<ex.f){ if(!ex) frontier.push({x:nx,y:ny,g,f}); else { ex.g=g; ex.f=f; } cameFrom.set(k,{x:cur.x,y:cur.y}); }
      }
      return 'visit';
    }
  }));

  // ---------- Machine Learning: k-Means ----------
  register({ id:'k-means', name:'k-Means Clustering', category:'ml', create(){
    let points=[], k=3, centers=[], assignments=[], done=false, seed=0, rng=Math.random, iter=0;
    return {
      init(_seed, _data, size){ seed=_seed; rng=mulberry32(seed); points = Data.points(size, rng); k = clamp(Math.round(Math.sqrt(size/12)), 2, 8); centers = Array.from({length:k},()=>({x:rng(),y:rng()})); assignments = new Array(points.length).fill(-1); done=false; iter=0; },
      step(dt){ if(done) return; iter++; // assign
        let changed=false; for(let i=0;i<points.length;i++){ let bi=0, bd=Infinity; for(let c=0;c<centers.length;c++){ const dx=points[i].x-centers[c].x, dy=points[i].y-centers[c].y; const d=dx*dx+dy*dy; if(d<bd){ bd=d; bi=c; } } if(assignments[i]!==bi){ assignments[i]=bi; changed=true; Audio.visit(); } }
        // recompute centers
        const sums=Array.from({length:k},()=>({x:0,y:0,n:0})); for(let i=0;i<points.length;i++){ const a=assignments[i]; sums[a].x+=points[i].x; sums[a].y+=points[i].y; sums[a].n++; }
        for(let c=0;c<k;c++){ if(sums[c].n>0){ centers[c].x=sums[c].x/sums[c].n; centers[c].y=sums[c].y/sums[c].n; } }
        if(!changed || iter>50){ done=true; Audio.done(); }
      },
      draw(ctx){ clear(ctx, ctx.canvas.width, ctx.canvas.height); const palette=(i)=>`hsl(${(i*67)%360} 80% 70%)`; const pts=points.map((p,i)=>({...p, c: assignments[i]===-1? 'rgba(255,255,255,.7)' : palette(assignments[i])})); const cts=centers.map((c,i)=>({...c, c: palette(i)})); drawPoints(ctx, pts, cts); },
      get finished(){ return done; },
      get stats(){ return { k, iterations: iter }; }
    }
  }});

  // ---------- Runner (single or battle) ----------
  const UI = {
    category: document.getElementById('category'),
    algorithm: document.getElementById('algorithm'),
    speed: document.getElementById('speed'),
    size: document.getElementById('size'),
    play: document.getElementById('play'),
    pause: document.getElementById('pause'),
    reset: document.getElementById('reset'),
    battle: document.getElementById('battle'),
    titleA: document.getElementById('titleA'),
    canvases: document.getElementById('canvases'),
    status: document.getElementById('status'),
    steps: document.getElementById('steps'),
    comps: document.getElementById('comps'),
    elapsed: document.getElementById('elapsed')
  };

  function createCanvasCard(id){
    const wrap=document.createElement('div'); wrap.className='canvas-card';
    const h=document.createElement('h3'); h.id = `title${id.toUpperCase()}`; h.textContent='Visualizer';
    const c=document.createElement('canvas'); c.id=`canvas${id.toUpperCase()}`; c.width=1280; c.height=480;
    wrap.appendChild(h); wrap.appendChild(c); return {wrap, h, c};
  }

  const App = (()=>{
    let ctxA, ctxB=null, ctrlA=null, ctrlB=null, running=false, last=0, stepCount=0, startTime=0, seed= (Math.random()*1e9)|0;

    function populateAlgorithms(){
      UI.algorithm.innerHTML=''; const list=Algorithms.listBy(UI.category.value); list.forEach(a=>{ const o=document.createElement('option'); o.value=a.id; o.textContent=a.name; UI.algorithm.appendChild(o); });
      // default selections
      const defaults = { sort:'quick-sort', graph:"dijkstra's", ml:'k-means' };
      const def = defaults[UI.category.value]; const has=[...UI.algorithm.options].some(o=>o.value===def); if(has) UI.algorithm.value=def;
    }

    function getCanvasContexts(){
      const cA=document.getElementById('canvasA'); ctxA=cA.getContext('2d'); if(UI.battle.checked){ if(!document.getElementById('canvasB')){ const second=createCanvasCard('b'); UI.canvases.appendChild(second.wrap); } const cB=document.getElementById('canvasB'); ctxB=cB.getContext('2d'); document.querySelector('.stage').classList.add('battle'); } else { const el=document.getElementById('canvasB'); if(el) el.parentElement.remove(); ctxB=null; document.querySelector('.stage').classList.remove('battle'); }
    }

    function instantiate(){
      const id=UI.algorithm.value; const spec=Algorithms.find(id) || Algorithms.listBy(UI.category.value)[0]; if(!spec) return;
      ctrlA = spec.create(); ctrlA.init(seed, null, parseInt(UI.size.value,10)); UI.titleA.textContent = spec.name + ' — A';
      if(UI.battle.checked){ // pick a different algorithm in same category if possible
        const list = Algorithms.listBy(UI.category.value); const alt = list.find(a=>a.id!==spec.id) || spec; ctrlB = alt.create(); ctrlB.init(seed, null, parseInt(UI.size.value,10)); const hB=document.getElementById('titleB'); if(hB) hB.textContent = alt.name + ' — B';
      } else ctrlB=null;
      stepCount=0; startTime=now(); UI.status.textContent='Ready'; UI.steps.textContent='0'; UI.comps.textContent='0'; UI.elapsed.textContent='0.0s';
    }

    function loop(ts){ if(!running){ last=ts; return; } const dt = clamp((ts-last)/1000 * parseFloat(UI.speed.value), 0, .25); last=ts; if(ctrlA && !ctrlA.finished){ ctrlA.step(dt); stepCount++; } if(ctrlB && !ctrlB.finished){ ctrlB.step(dt); stepCount++; }
      if(ctxA){ ctrlA?.draw(ctxA); } if(ctxB){ ctrlB?.draw(ctxB); }
      // stats
      const comps = (ctrlA?.stats?.comps||ctrlA?.stats?.visits||0) + (ctrlB? (ctrlB.stats?.comps||ctrlB.stats?.visits||0) : 0);
      UI.steps.textContent = stepCount.toString(); UI.comps.textContent = comps.toString(); UI.elapsed.textContent = ((now()-startTime)/1000).toFixed(1)+ 's';
      if( (ctrlA?.finished??true) && (ctrlB?.finished ?? true) ) { running=false; UI.status.textContent='Done'; }
      requestAnimationFrame(loop);
    }

    function play(){ running=true; UI.status.textContent='Running'; requestAnimationFrame(loop); }
    function pause(){ running=false; UI.status.textContent='Paused'; }
    function reset(){ seed = (Math.random()*1e9)|0; instantiate(); if(running) requestAnimationFrame(loop); }

    // Events
    UI.category.addEventListener('change', ()=>{ populateAlgorithms(); instantiate(); });
    UI.algorithm.addEventListener('change', ()=>instantiate());
    UI.size.addEventListener('input', ()=>instantiate());
    UI.battle.addEventListener('change', ()=>{ getCanvasContexts(); instantiate(); });
    UI.play.addEventListener('click', play); UI.pause.addEventListener('click', pause); UI.reset.addEventListener('click', reset);

    window.addEventListener('resize', ()=>{ getCanvasContexts(); });

    function init(){ populateAlgorithms(); getCanvasContexts(); instantiate(); }

    return { init };
  })();

  // Init
  document.getElementById('year').textContent = new Date().getFullYear();
  App.init();
  </script>
</body>
</html>
