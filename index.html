<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algorithm Visualizer Pro</title>
  <style>
    :root {
      --bg-dark: #0a0a0a;
      --bg-medium: #1a1a1a;
      --bg-light: #2a2a2a;
      --bg-canvas: #0f0f0f;
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --border-color: #333;
      --accent-blue: #4FC3F7;
      --accent-purple: #9C27B0;
      --accent-green: #4CAF50;
      --accent-orange: #FF9800;
      --accent-red: #F44336;
      --accent-yellow: #FFC107;
      --glow: rgba(79, 195, 247, 0.3);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1a2e 100%);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    header {
      background: linear-gradient(135deg, var(--bg-medium) 0%, #16213e 100%);
      padding: 1.5rem;
      border-bottom: 2px solid var(--border-color);
      box-shadow: 0 4px 20px var(--glow);
    }

    h1 {
      margin: 0 0 1.5rem 0;
      font-size: 2.2em;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(45deg, var(--accent-blue), var(--accent-purple), var(--accent-green));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 10px var(--glow));
    }

    #controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 1rem;
      align-items: end;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .control-group label {
      font-size: 0.9em;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    select, input[type=range], button {
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-light);
      color: var(--text-primary);
      font-size: 1em;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    select:focus, input:focus, button:focus {
      outline: none;
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 2px var(--glow);
    }

    button {
      font-weight: 600;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
      border: none;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--accent-green), #66BB6A);
    }

    .btn-warning {
      background: linear-gradient(135deg, var(--accent-orange), var(--accent-yellow));
    }

    main {
      flex-grow: 1;
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      padding: 1rem;
      overflow: hidden;
    }

    main.battle-mode {
      grid-template-columns: 1fr 1fr;
    }

    .canvas-container {
      position: relative;
      background: var(--bg-canvas);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #canvasBattle {
      display: none;
    }

    main.battle-mode #canvasBattle {
      display: block;
    }

    .stats-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 8px;
      font-size: 0.85em;
      min-width: 150px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .stats-panel div {
      margin: 2px 0;
    }

    .algorithm-info {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8em;
      font-weight: 600;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      background: transparent;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-track {
      background: var(--bg-light);
      height: 6px;
      border-radius: 3px;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 18px;
      width: 18px;
      border-radius: 50%;
      background: linear-gradient(45deg, var(--accent-blue), var(--accent-purple));
      cursor: pointer;
      box-shadow: 0 0 10px var(--glow);
    }

    /* Responsive design */
    @media (max-width: 768px) {
      #controls {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 1.8em;
      }
      
      main.battle-mode {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr 1fr;
      }
    }

    /* Animation classes */
    .highlight-red { background-color: #ff6b6b !important; }
    .highlight-blue { background-color: #4ecdc4 !important; }
    .highlight-green { background-color: #45b7d1 !important; }
    .highlight-yellow { background-color: #feca57 !important; }
    .highlight-purple { background-color: #ff9ff3 !important; }
  </style>
</head>
<body>
  <header>
    <h1>Algorithm Visualizer Pro</h1>
    <div id="controls">
      <div class="control-group">
        <label>Category</label>
        <select id="categorySelect">
          <option value="sorting">Sorting</option>
          <option value="searching">Searching</option>
          <option value="pathfinding">Pathfinding</option>
        </select>
      </div>
      
      <div class="control-group">
        <label>Algorithm</label>
        <select id="algorithmSelect"></select>
      </div>
      
      <div class="control-group">
        <label>Speed: <span id="speedValue">1x</span></label>
        <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1">
      </div>
      
      <div class="control-group">
        <label>Size: <span id="sizeValue">100</span></label>
        <input type="range" id="sizeSlider" min="10" max="300" step="10" value="100">
      </div>
      
      <button id="playPauseBtn">▶ Play</button>
      <button id="resetBtn" class="btn-success">🔄 Reset</button>
      <button id="battleModeBtn" class="btn-warning">⚔ Battle Mode</button>
    </div>
  </header>

  <main>
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <div id="statsA" class="stats-panel"></div>
      <div id="algoInfoA" class="algorithm-info"></div>
    </div>
    <div class="canvas-container">
      <canvas id="canvasBattle"></canvas>
      <div id="statsB" class="stats-panel"></div>
      <div id="algoInfoB" class="algorithm-info"></div>
    </div>
  </main>

  <script>
    // Seeded Random Number Generator
    class SeededRNG {
      constructor(seed) {
        this.seed = seed;
        this.state = seed;
      }
      
      next() {
        this.state = (this.state * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.state / Math.pow(2, 32);
      }
      
      random() { return this.next(); }
      int(min, max) { return Math.floor(min + this.random() * (max - min + 1)); }
    }

    // Audio Engine for sound feedback
    class AudioEngine {
      constructor() {
        this.enabled = true;
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.audioContext.createGain();
          this.masterGain.gain.value = 0.1;
          this.masterGain.connect(this.audioContext.destination);
        } catch (e) {
          this.enabled = false;
        }
      }

      playTone(frequency, duration = 0.1, type = 'sine') {
        if (!this.enabled) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.masterGain);
        
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0.3, this.audioContext.currentTime + 0.01);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      compare() { this.playTone(800, 0.05); }
      swap() { this.playTone(400, 0.1, 'square'); }
      access() { this.playTone(600, 0.05); }
      complete() { this.playTone(300, 0.3, 'sawtooth'); }
    }

    // Base Algorithm Class
    class Algorithm {
      constructor(canvas, audioEngine, name) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.audio = audioEngine;
        this.name = name;
        this.isComplete = false;
        this.stats = {};
        this.highlights = {};
      }

      init(seed, size) { throw new Error('Must implement init()'); }
      step() { throw new Error('Must implement step()'); }
      draw() { throw new Error('Must implement draw()'); }
      
      get finished() { return this.isComplete; }
      
      clear(color = '#0f0f0f') {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }
      
      finish() {
        this.isComplete = true;
        this.audio.complete();
      }
    }

    // Sorting Algorithms
    class SortingAlgorithm extends Algorithm {
      constructor(canvas, audioEngine, name) {
        super(canvas, audioEngine, name);
        this.array = [];
        this.stats = { comparisons: 0, swaps: 0, accesses: 0, steps: 0 };
      }

      init(seed, size) {
        const rng = new SeededRNG(seed);
        this.array = Array.from({ length: size }, () => rng.int(5, 100));
        this.isComplete = false;
        this.stats = { comparisons: 0, swaps: 0, accesses: 0, steps: 0 };
        this.highlights = {};
      }

      draw() {
        this.clear();
        const { width, height } = this.canvas;
        const barWidth = width / this.array.length;
        const maxValue = Math.max(...this.array);

        for (let i = 0; i < this.array.length; i++) {
          const barHeight = (this.array[i] / maxValue) * (height - 20);
          
          // Default color
          let color = '#4a90e2';
          
          // Apply highlights
          if (this.highlights[i]) {
            color = this.highlights[i];
          }
          
          // Draw bar with gradient
          const gradient = this.ctx.createLinearGradient(0, height - barHeight, 0, height);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, this.darkenColor(color, 0.3));
          
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
          
          // Add glow for highlighted elements
          if (this.highlights[i]) {
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = 15;
            this.ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
            this.ctx.shadowBlur = 0;
          }
        }
        
        // Clear highlights after drawing
        this.highlights = {};
      }

      darkenColor(color, amount) {
        const colorMap = {
          '#ff6b6b': '#cc5555',
          '#4ecdc4': '#3ba39d',
          '#45b7d1': '#3692a7',
          '#feca57': '#cb9f46',
          '#ff9ff3': '#cc7fc2',
          '#4a90e2': '#3a73b5'
        };
        return colorMap[color] || color;
      }
    }

    class BubbleSort extends SortingAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.i = 0;
        this.j = 0;
        this.n = this.array.length;
      }

      step() {
        if (this.isComplete) return;
        
        this.stats.steps++;
        
        if (this.i >= this.n - 1) {
          this.finish();
          return;
        }

        if (this.j >= this.n - 1 - this.i) {
          this.highlights[this.n - 1 - this.i] = '#4ecdc4'; // Mark as sorted
          this.i++;
          this.j = 0;
          return;
        }

        // Highlight current comparison
        this.highlights[this.j] = '#ff6b6b';
        this.highlights[this.j + 1] = '#ff6b6b';
        
        this.stats.comparisons++;
        this.stats.accesses += 2;
        
        if (this.array[this.j] > this.array[this.j + 1]) {
          // Swap
          [this.array[this.j], this.array[this.j + 1]] = [this.array[this.j + 1], this.array[this.j]];
          this.stats.swaps++;
          this.highlights[this.j] = '#feca57';
          this.highlights[this.j + 1] = '#feca57';
          this.audio.swap();
        } else {
          this.audio.compare();
        }
        
        this.j++;
      }
    }

    class QuickSort extends SortingAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.stack = [{low: 0, high: this.array.length - 1}];
        this.currentPivot = -1;
        this.partitionStep = null;
      }

      step() {
        if (this.isComplete) return;
        
        this.stats.steps++;
        
        if (this.stack.length === 0) {
          this.finish();
          return;
        }

        const {low, high} = this.stack.pop();
        
        if (low < high) {
          const pivotIndex = this.partition(low, high);
          this.stack.push({low: low, high: pivotIndex - 1});
          this.stack.push({low: pivotIndex + 1, high: high});
          this.highlights[pivotIndex] = '#4ecdc4';
          this.audio.swap();
        }
      }

      partition(low, high) {
        const pivot = this.array[high];
        this.highlights[high] = '#ff9ff3'; // Pivot color
        let i = low - 1;

        for (let j = low; j < high; j++) {
          this.stats.comparisons++;
          this.stats.accesses += 2;
          this.highlights[j] = '#feca57';
          
          if (this.array[j] < pivot) {
            i++;
            [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
            this.stats.swaps++;
            this.highlights[i] = '#45b7d1';
          }
        }
        
        [this.array[i + 1], this.array[high]] = [this.array[high], this.array[i + 1]];
        this.stats.swaps++;
        return i + 1;
      }
    }

    class SelectionSort extends SortingAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.i = 0;
        this.j = 1;
        this.minIndex = 0;
        this.n = this.array.length;
      }

      step() {
        if (this.isComplete) return;
        
        this.stats.steps++;
        
        if (this.i >= this.n - 1) {
          this.finish();
          return;
        }

        if (this.j >= this.n) {
          // End of inner loop - perform swap
          if (this.minIndex !== this.i) {
            [this.array[this.i], this.array[this.minIndex]] = [this.array[this.minIndex], this.array[this.i]];
            this.stats.swaps++;
            this.audio.swap();
          }
          
          this.highlights[this.i] = '#4ecdc4'; // Mark as sorted
          this.i++;
          this.minIndex = this.i;
          this.j = this.i + 1;
          return;
        }

        // Highlight current comparison
        this.highlights[this.minIndex] = '#ff6b6b';
        this.highlights[this.j] = '#feca57';
        
        this.stats.comparisons++;
        this.stats.accesses += 2;
        
        if (this.array[this.j] < this.array[this.minIndex]) {
          this.minIndex = this.j;
        }
        
        this.audio.compare();
        this.j++;
      }
    }

    // Search Algorithms
    class SearchAlgorithm extends Algorithm {
      constructor(canvas, audioEngine, name) {
        super(canvas, audioEngine, name);
        this.array = [];
        this.target = 0;
        this.found = false;
        this.foundIndex = -1;
        this.stats = { comparisons: 0, accesses: 0, steps: 0 };
      }

      init(seed, size) {
        const rng = new SeededRNG(seed);
        this.array = Array.from({ length: size }, (_, i) => i + 1);
        // Shuffle array
        for (let i = this.array.length - 1; i > 0; i--) {
          const j = rng.int(0, i);
          [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
        }
        
        this.target = this.array[rng.int(0, this.array.length - 1)];
        this.found = false;
        this.foundIndex = -1;
        this.isComplete = false;
        this.stats = { comparisons: 0, accesses: 0, steps: 0 };
        this.highlights = {};
      }

      draw() {
        this.clear();
        const { width, height } = this.canvas;
        const barWidth = width / this.array.length;
        const maxValue = Math.max(...this.array);

        // Draw target info
        this.ctx.fillStyle = '#ff6b6b';
        this.ctx.font = 'bold 16px Arial';
        this.ctx.fillText(`Target: ${this.target}`, 10, 25);

        for (let i = 0; i < this.array.length; i++) {
          const barHeight = (this.array[i] / maxValue) * (height - 40);
          
          let color = '#4a90e2';
          if (this.found && i === this.foundIndex) {
            color = '#4ecdc4'; // Found
          } else if (this.highlights[i]) {
            color = this.highlights[i];
          }
          
          this.ctx.fillStyle = color;
          this.ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
          
          // Draw value if space allows
          if (barWidth > 20) {
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '10px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(this.array[i], i * barWidth + barWidth/2, height - 5);
          }
        }
        
        this.highlights = {};
      }
    }

    class LinearSearch extends SearchAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.currentIndex = 0;
      }

      step() {
        if (this.isComplete) return;
        
        this.stats.steps++;
        
        if (this.currentIndex >= this.array.length) {
          this.finish();
          return;
        }

        this.highlights[this.currentIndex] = '#feca57';
        this.stats.accesses++;
        this.stats.comparisons++;

        if (this.array[this.currentIndex] === this.target) {
          this.found = true;
          this.foundIndex = this.currentIndex;
          this.finish();
          return;
        }

        this.audio.compare();
        this.currentIndex++;
      }
    }

    class BinarySearch extends SearchAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.array.sort((a, b) => a - b); // Binary search requires sorted array
        this.left = 0;
        this.right = this.array.length - 1;
        this.mid = -1;
      }

      step() {
        if (this.isComplete) return;
        
        this.stats.steps++;
        
        if (this.left > this.right) {
          this.finish();
          return;
        }

        this.mid = Math.floor((this.left + this.right) / 2);
        
        // Highlight search range
        this.highlights[this.left] = '#ff9ff3';
        this.highlights[this.right] = '#ff9ff3';
        this.highlights[this.mid] = '#feca57';

        this.stats.accesses++;
        this.stats.comparisons++;

        if (this.array[this.mid] === this.target) {
          this.found = true;
          this.foundIndex = this.mid;
          this.finish();
          return;
        }

        if (this.array[this.mid] < this.target) {
          this.left = this.mid + 1;
        } else {
          this.right = this.mid - 1;
        }

        this.audio.compare();
      }
    }

    // Pathfinding Algorithms
    class PathfindingAlgorithm extends Algorithm {
      constructor(canvas, audioEngine, name) {
        super(canvas, audioEngine, name);
        this.gridSize = 40;
        this.grid = [];
        this.start = null;
        this.goal = null;
        this.visited = new Set();
        this.path = [];
        this.stats = { nodesVisited: 0, pathLength: 0, steps: 0 };
      }

      init(seed) {
        const rng = new SeededRNG(seed);
        this.grid = [];
        
        // Initialize grid
        for (let y = 0; y < this.gridSize; y++) {
          this.grid[y] = [];
          for (let x = 0; x < this.gridSize; x++) {
            this.grid[y][x] = {
              x, y,
              isWall: rng.random() < 0.3,
              isVisited: false,
              isPath: false,
              distance: Infinity,
              parent: null
            };
          }
        }

        // Set start and goal
        this.start = this.grid[1][1];
        this.goal = this.grid[this.gridSize - 2][this.gridSize - 2];
        this.start.isWall = false;
        this.goal.isWall = false;

        this.visited.clear();
        this.path = [];
        this.isComplete = false;
        this.stats = { nodesVisited: 0, pathLength: 0, steps: 0 };
      }

      draw() {
        this.clear();
        const { width, height } = this.canvas;
        const cellSize = Math.min(width / this.gridSize, height / this.gridSize);

        for (let y = 0; y < this.gridSize; y++) {
          for (let x = 0; x < this.gridSize; x++) {
            const cell = this.grid[y][x];
            const pixelX = x * cellSize;
            const pixelY = y * cellSize;

            let color = '#2a2a2a';
            if (cell.isWall) color = '#666';
            if (cell.isVisited) color = '#4ecdc4';
            if (cell.isPath) color = '#feca57';
            if (cell === this.start) color = '#4CAF50';
            if (cell === this.goal) color = '#F44336';

            this.ctx.fillStyle = color;
            this.ctx.fillRect(pixelX, pixelY, cellSize - 1, cellSize - 1);
          }
        }
      }

      getNeighbors(cell) {
        const neighbors = [];
        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
        
        for (const [dx, dy] of directions) {
          const newX = cell.x + dx;
          const newY = cell.y + dy;
          
          if (newX >= 0 && newX < this.gridSize && newY >= 0 && newY < this.gridSize) {
            const neighbor = this.grid[newY][newX];
            if (!neighbor.isWall) {
              neighbors.push(neighbor);
            }
          }
        }
        
        return neighbors;
      }

      reconstructPath(endCell) {
        this.path = [];
        let current = endCell;
        
        while (current && current !== this.start) {
          current.isPath = true;
          this.path.unshift(current);
          current = current.parent;
        }
        
        if (this.start) {
          this.start.isPath = true;
        }
        
        this.stats.pathLength = this.path.length;
      }
    }

    class BFS extends PathfindingAlgorithm {
      init(seed) {
        super.init(seed);
        this.queue = [this.start];
        this.start.isVisited = true;
        this.start.distance = 0;
      }

      step() {
        if (this.isComplete) return;
        
        this.stats.steps++;
        
        if (this.queue.length === 0) {
          this.finish();
          return;
        }

        const current = this.queue.shift();
        this.stats.nodesVisited++;

        if (current === this.goal) {
          this.reconstructPath(current);
          this.finish();
          return;
        }

        const neighbors = this.getNeighbors(current);
        for (const neighbor of neighbors) {
          if (!neighbor.isVisited) {
            neighbor.isVisited = true;
            neighbor.parent = current;
            neighbor.distance = current.distance + 1;
            this.queue.push(neighbor);
          }
        }

        this.audio.access();
      }
    }

    class DFS extends PathfindingAlgorithm {
      init(seed) {
        super.init(seed);
        this.stack = [this.start];
        this.start.isVisited = true;
      }

      step() {
        if (this.isComplete) return;
        
        this.stats.steps++;
        
        if (this.stack.length === 0) {
          this.finish();
          return;
        }

        const current = this.stack.pop();
        this.stats.nodesVisited++;

        if (current === this.goal) {
          this.reconstructPath(current);
          this.finish();
          return;
        }

        const neighbors = this.getNeighbors(current);
        for (const neighbor of neighbors) {
          if (!neighbor.isVisited) {
            neighbor.isVisited = true;
            neighbor.parent = current;
            this.stack.push(neighbor);
          }
        }

        this.audio.access();
      }
    }

    // Algorithm Registry
    const ALGORITHMS = {
      sorting: {
        'bubble-sort': { name: 'Bubble Sort', class: BubbleSort, desc: 'O(n²) - Simple comparison-based sort' },
        'selection-sort': { name: 'Selection Sort', class: SelectionSort, desc: 'O(n²) - Finds minimum element repeatedly' },
        'quick-sort': { name: 'Quick Sort', class: QuickSort, desc: 'O(n log n) - Efficient divide-and-conquer sort' }
      },
      searching: {
        'linear-search': { name: 'Linear Search', class: LinearSearch, desc: 'O(n) - Sequential search through array' },
        'binary-search': { name: 'Binary Search', class: BinarySearch, desc: 'O(log n) - Efficient search on sorted array' }
      },
      pathfinding: {
        'bfs': { name: 'Breadth-First Search', class: BFS, desc: 'Explores all neighbors before going deeper' },
        'dfs': { name: 'Depth-First Search', class: DFS, desc: 'Explores as far as possible before backtracking' }
      }
    };

    // Main Application Class
    class AlgorithmVisualizer {
      constructor() {
        this.initializeDOM();
        this.audioEngine = new AudioEngine();
        this.algorithmA = null;
        this.algorithmB = null;
        this.isPlaying = false;
        this.animationId = null;
        this.lastStepTime = 0;
        this.seed = Date.now();

        this.setupEventListeners();
        this.populateControls();
        this.resizeCanvases();
        this.resetAlgorithms();
        this.startAnimationLoop();
      }

      initializeDOM() {
        this.elements = {
          categorySelect: document.getElementById('categorySelect'),
          algorithmSelect: document.getElementById('algorithmSelect'),
          speedSlider: document.getElementById('speedSlider'),
          speedValue: document.getElementById('speedValue'),
          sizeSlider: document.getElementById('sizeSlider'),
          sizeValue: document.getElementById('sizeValue'),
          playPauseBtn: document.getElementById('playPauseBtn'),
          resetBtn: document.getElementById('resetBtn'),
          battleModeBtn: document.getElementById('battleModeBtn'),
          canvasA: document.getElementById('canvas'),
          canvasB: document.getElementById('canvasBattle'),
          main: document.querySelector('main'),
          statsA: document.getElementById('statsA'),
          statsB: document.getElementById('statsB'),
          algoInfoA: document.getElementById('algoInfoA'),
          algoInfoB: document.getElementById('algoInfoB')
        };
      }

      setupEventListeners() {
        // Control events
        this.elements.categorySelect.addEventListener('change', () => {
          this.populateAlgorithms();
          this.resetAlgorithms();
        });

        this.elements.algorithmSelect.addEventListener('change', () => {
          this.resetAlgorithms();
        });

        this.elements.speedSlider.addEventListener('input', (e) => {
          this.elements.speedValue.textContent = `${parseFloat(e.target.value).toFixed(1)}x`;
        });

        this.elements.sizeSlider.addEventListener('input', (e) => {
          this.elements.sizeValue.textContent = e.target.value;
          this.resetAlgorithms();
        });

        this.elements.playPauseBtn.addEventListener('click', () => {
          this.togglePlayPause();
        });

        this.elements.resetBtn.addEventListener('click', () => {
          this.resetAlgorithms(true);
        });

        this.elements.battleModeBtn.addEventListener('click', () => {
          this.toggleBattleMode();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          switch (e.code) {
            case 'Space':
              e.preventDefault();
              this.togglePlayPause();
              break;
            case 'KeyR':
              e.preventDefault();
              this.resetAlgorithms(true);
              break;
            case 'KeyB':
              e.preventDefault();
              this.toggleBattleMode();
              break;
          }
        });

        // Window resize
        window.addEventListener('resize', () => {
          this.resizeCanvases();
        });
      }

      populateControls() {
        // Populate categories
        this.elements.categorySelect.innerHTML = Object.keys(ALGORITHMS)
          .map(key => `<option value="${key}">${key.charAt(0).toUpperCase() + key.slice(1)}</option>`)
          .join('');

        this.populateAlgorithms();
      }

      populateAlgorithms() {
        const category = this.elements.categorySelect.value;
        const algorithms = ALGORITHMS[category] || {};
        
        this.elements.algorithmSelect.innerHTML = Object.entries(algorithms)
          .map(([key, {name}]) => `<option value="${key}">${name}</option>`)
          .join('');
      }

      resizeCanvases() {
        const devicePixelRatio = window.devicePixelRatio || 1;
        
        [this.elements.canvasA, this.elements.canvasB].forEach(canvas => {
          const container = canvas.parentElement;
          const rect = container.getBoundingClientRect();
          
          canvas.width = rect.width * devicePixelRatio;
          canvas.height = rect.height * devicePixelRatio;
          
          const ctx = canvas.getContext('2d');
          ctx.scale(devicePixelRatio, devicePixelRatio);
          
          canvas.style.width = rect.width + 'px';
          canvas.style.height = rect.height + 'px';
        });

        // Redraw if algorithms exist
        if (this.algorithmA) this.algorithmA.draw();
        if (this.algorithmB) this.algorithmB.draw();
      }

      resetAlgorithms(newSeed = false) {
        this.isPlaying = false;
        this.elements.playPauseBtn.textContent = '▶ Play';
        
        if (newSeed) {
          this.seed = Date.now();
        }

        const category = this.elements.categorySelect.value;
        const algorithmKey = this.elements.algorithmSelect.value;
        const size = parseInt(this.elements.sizeSlider.value);

        if (!ALGORITHMS[category] || !ALGORITHMS[category][algorithmKey]) {
          return;
        }

        const AlgorithmClass = ALGORITHMS[category][algorithmKey].class;
        const algorithmInfo = ALGORITHMS[category][algorithmKey];

        // Initialize primary algorithm
        this.algorithmA = new AlgorithmClass(this.elements.canvasA, this.audioEngine, algorithmInfo.name);
        this.algorithmA.init(this.seed, size);

        // Update info display
        this.elements.algoInfoA.textContent = `${algorithmInfo.name} - ${algorithmInfo.desc}`;

        // Initialize battle mode algorithm if enabled
        if (this.elements.main.classList.contains('battle-mode')) {
          const algorithmKeys = Object.keys(ALGORITHMS[category]);
          const otherKey = algorithmKeys.find(key => key !== algorithmKey) || algorithmKeys[0];
          const OtherAlgorithmClass = ALGORITHMS[category][otherKey].class;
          const otherInfo = ALGORITHMS[category][otherKey];

          this.algorithmB = new OtherAlgorithmClass(this.elements.canvasB, this.audioEngine, otherInfo.name);
          this.algorithmB.init(this.seed, size);
          this.elements.algoInfoB.textContent = `${otherInfo.name} - ${otherInfo.desc}`;
        } else {
          this.algorithmB = null;
          this.elements.algoInfoB.textContent = '';
          this.elements.statsB.innerHTML = '';
        }

        // Initial draw and stats update
        this.drawAlgorithms();
        this.updateStats();
      }

      togglePlayPause() {
        this.isPlaying = !this.isPlaying;
        this.elements.playPauseBtn.textContent = this.isPlaying ? '⏸ Pause' : '▶ Play';
        
        if (this.isPlaying) {
          this.lastStepTime = performance.now();
        }
      }

      toggleBattleMode() {
        this.elements.main.classList.toggle('battle-mode');
        const isBattleMode = this.elements.main.classList.contains('battle-mode');
        this.elements.battleModeBtn.textContent = isBattleMode ? '👁 Single Mode' : '⚔ Battle Mode';
        
        this.resizeCanvases();
        this.resetAlgorithms();
      }

      drawAlgorithms() {
        if (this.algorithmA) this.algorithmA.draw();
        if (this.algorithmB) this.algorithmB.draw();
      }

      updateStats() {
        if (this.algorithmA) {
          this.elements.statsA.innerHTML = Object.entries(this.algorithmA.stats)
            .map(([key, value]) => {
              const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
              return `<div><strong>${formattedKey}:</strong> ${value}</div>`;
            })
            .join('');
        }

        if (this.algorithmB) {
          this.elements.statsB.innerHTML = Object.entries(this.algorithmB.stats)
            .map(([key, value]) => {
              const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
              return `<div><strong>${formattedKey}:</strong> ${value}</div>`;
            })
            .join('');
        }
      }

      startAnimationLoop() {
        const animate = (currentTime) => {
          const speed = parseFloat(this.elements.speedSlider.value);
          const stepInterval = Math.max(50, 500 / speed);

          if (this.isPlaying && currentTime - this.lastStepTime >= stepInterval) {
            let hasActiveAlgorithm = false;

            if (this.algorithmA && !this.algorithmA.finished) {
              this.algorithmA.step();
              hasActiveAlgorithm = true;
            }

            if (this.algorithmB && !this.algorithmB.finished) {
              this.algorithmB.step();
              hasActiveAlgorithm = true;
            }

            if (hasActiveAlgorithm) {
              this.drawAlgorithms();
              this.updateStats();
              this.lastStepTime = currentTime;
            } else {
              // All algorithms finished
              this.isPlaying = false;
              this.elements.playPauseBtn.textContent = '▶ Play';
            }
          }

          this.animationId = requestAnimationFrame(animate);
        };

        animate(0);
      }
    }

    // Initialize the application when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      new AlgorithmVisualizer();
    });
  </script>
</body>
</html>