<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algorithm Visualizer Pro</title>
  <style>
    :root {
      --bg-dark: #0f0f0f;
      --bg-medium: #1a1a1a;
      --bg-light: #2a2a2a;
      --bg-canvas: #121212;
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --border-color: #333;
      --accent-yellow: #ffd700;
      --accent-green: #00ff7f;
      --accent-red: #ff4757;
      --accent-blue: #70a1ff;
      --accent-purple: #a55eea;
      --accent-orange: #ff6348;
      --glow-color: #00ffff;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1a2e 100%);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    header {
      background: linear-gradient(135deg, var(--bg-medium) 0%, #16213e 100%);
      padding: 1.5rem;
      border-bottom: 2px solid var(--border-color);
      box-shadow: 0 4px 20px rgba(0, 255, 255, 0.1);
    }

    h1 {
      margin: 0 0 1.5rem 0;
      font-size: 2.2em;
      font-weight: 700;
      text-align: center;
      background: linear-gradient(45deg, var(--accent-blue), var(--accent-purple), var(--accent-green));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(112, 161, 255, 0.5);
    }

    #controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      align-items: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .control-group label {
      font-size: 0.9em;
      font-weight: 500;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    select, input[type=range], button {
      padding: 12px 16px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: linear-gradient(135deg, var(--bg-light) 0%, #2a2a3e 100%);
      color: var(--text-primary);
      font-size: 1em;
      transition: all 0.3s ease;
    }

    select:focus, input:focus, button:focus {
      outline: none;
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 3px rgba(112, 161, 255, 0.2);
    }

    button {
      cursor: pointer;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }

    button:hover {
      background: linear-gradient(135deg, #3a3a4e 0%, #4a4a6e 100%);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    button:active {
      transform: translateY(0);
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-blue) 0%, var(--accent-purple) 100%);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--accent-green) 0%, #00d2d3 100%);
    }

    .btn-warning {
      background: linear-gradient(135deg, var(--accent-yellow) 0%, var(--accent-orange) 100%);
    }

    main {
      flex-grow: 1;
      display: grid;
      grid-template-columns: 1fr;
      gap: 1rem;
      padding: 1rem;
      overflow: hidden;
    }

    main.battle-mode {
      grid-template-columns: 1fr 1fr;
    }

    .canvas-container {
      position: relative;
      background: linear-gradient(135deg, var(--bg-canvas) 0%, #1a1a2e 100%);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .canvas-container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 49%, rgba(0, 255, 255, 0.1) 50%, transparent 51%);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .canvas-container:hover::before {
      opacity: 1;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #canvasBattle {
      display: none;
    }

    main.battle-mode #canvasBattle {
      display: block;
    }

    .stats-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px;
      border-radius: 8px;
      font-size: 0.85em;
      min-width: 150px;
      backdrop-filter: blur(10px);
    }

    .stats-panel div {
      margin: 2px 0;
    }

    .algorithm-info {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.8);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8em;
      font-weight: 600;
      backdrop-filter: blur(10px);
    }

    footer {
      background: linear-gradient(135deg, var(--bg-medium) 0%, #16213e 100%);
      text-align: center;
      padding: 1rem;
      font-size: 0.9em;
      border-top: 2px solid var(--border-color);
      color: var(--text-secondary);
    }

    /* Range slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      background: transparent;
      cursor: pointer;
    }

    input[type="range"]::-webkit-slider-track {
      background: var(--bg-light);
      height: 6px;
      border-radius: 3px;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      height: 18px;
      width: 18px;
      border-radius: 50%;
      background: linear-gradient(45deg, var(--accent-blue), var(--accent-purple));
      cursor: pointer;
      box-shadow: 0 0 10px rgba(112, 161, 255, 0.5);
    }

    /* Loading animation */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: var(--accent-blue);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Responsive design */
    @media (max-width: 768px) {
      #controls {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 1.8em;
      }
      
      main.battle-mode {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr 1fr;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Algorithm Visualizer Pro</h1>
    <div id="controls">
      <div class="control-group">
        <label>Category</label>
        <select id="categorySelect"></select>
      </div>
      
      <div class="control-group">
        <label>Algorithm</label>
        <select id="algorithmSelect"></select>
      </div>
      
      <div class="control-group">
        <label>Speed</label>
        <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1" />
      </div>
      
      <div class="control-group">
        <label>Size</label>
        <input type="range" id="sizeSlider" min="10" max="500" step="10" value="100" />
      </div>
      
      <button id="playPauseBtn" class="btn-primary">▶ Play</button>
      <button id="resetBtn" class="btn-success">🔄 Reset</button>
      <button id="battleModeBtn" class="btn-warning">⚔ Battle Mode</button>
    </div>
  </header>

  <main>
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <div id="statsA" class="stats-panel"></div>
      <div id="algoInfoA" class="algorithm-info"></div>
    </div>
    <div class="canvas-container">
      <canvas id="canvasBattle"></canvas>
      <div id="statsB" class="stats-panel"></div>
      <div id="algoInfoB" class="algorithm-info"></div>
    </div>
  </main>

  <footer>
    <p>Algorithm Visualizer Pro - Experience algorithms like never before</p>
  </footer>

  <script>
    /*
      Enhanced Algorithm Visualizer with extensive algorithms and features
    */

    // ========================= Audio Engine =========================
    class AudioEngine {
      constructor() {
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.value = 0.15;
          this.masterGain.connect(this.ctx.destination);
        } catch (e) {
          console.warn("Web Audio API not supported");
          this.ctx = null;
        }
      }

      _createTone(type, freq, duration, attack = 0.01, decay = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(0.0001, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.3, this.ctx.currentTime + attack);
        gain.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
      }

      compare() { this._createTone('triangle', 800, 0.05); }
      swap() { this._createTone('square', 400, 0.08); }
      access() { this._createTone('sine', 600, 0.04); }
      finish() { this._createTone('sawtooth', 300, 0.3, 0.02, 0.25); }
      error() { this._createTone('sawtooth', 150, 0.15); }
    }

    // ========================= Utilities =========================
    class SeededRNG {
      constructor(seed) {
        this.seed = seed;
        this.state = seed;
      }
      
      next() {
        this.state = (this.state * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.state / Math.pow(2, 32);
      }
      
      random() { return this.next(); }
      range(min, max) { return min + this.random() * (max - min); }
      int(min, max) { return Math.floor(this.range(min, max + 1)); }
    }

    // ========================= Base Algorithm Class =========================
    class Algorithm {
      constructor(canvas, sfx, name) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.sfx = sfx;
        this.name = name;
        this.isDone = false;
        this.stats = {};
        this.highlights = {};
      }

      init(seed, size) { throw new Error("Must implement init()"); }
      step() { throw new Error("Must implement step()"); }
      draw() { throw new Error("Must implement draw()"); }
      
      get finished() { return this.isDone; }
      
      _clear(color = '#121212') {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }
      
      _finish() {
        this.isDone = true;
        this.sfx.finish();
      }
    }

    // ========================= Sorting Algorithms =========================
    class SortingAlgorithm extends Algorithm {
      constructor(canvas, sfx, name) {
        super(canvas, sfx, name);
        this.arr = [];
        this.stats = { comparisons: 0, swaps: 0, accesses: 0, steps: 0 };
      }

      init(seed, size) {
        const rng = new SeededRNG(seed);
        this.arr = Array.from({ length: size }, () => rng.int(1, 100));
        this.isDone = false;
        this.stats = { comparisons: 0, swaps: 0, accesses: 0, steps: 0 };
        this.highlights = {};
      }

      draw() {
        this._clear();
        const { width, height } = this.canvas;
        const n = this.arr.length;
        const barWidth = width / n;
        const maxVal = Math.max(...this.arr, 1);

        for (let i = 0; i < n; i++) {
          const barHeight = Math.max(2, (this.arr[i] / maxVal) * (height - 20));
          let color = '#4a4a4a';
          
          if (this.highlights[i]) {
            color = this.highlights[i];
          }
          
          // Gradient effect
          const gradient = this.ctx.createLinearGradient(0, height - barHeight, 0, height);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, this._darkenColor(color, 0.3));
          
          this.ctx.fillStyle = gradient;
          this.ctx.fillRect(i * barWidth + 1, height - barHeight - 10, Math.max(1, barWidth - 2), barHeight);
          
          // Add glow effect for highlighted bars
          if (this.highlights[i]) {
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = 10;
            this.ctx.fillRect(i * barWidth + 1, height - barHeight - 10, Math.max(1, barWidth - 2), barHeight);
            this.ctx.shadowBlur = 0;
          }
        }
        this.highlights = {};
      }
      
      _darkenColor(color, amount) {
        return color + Math.floor(255 * amount).toString(16).padStart(2, '0');
      }
    }

    class BubbleSort extends SortingAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.i = 0;
        this.j = 0;
      }

      step() {
        if (this.finished) return;
        this.stats.steps++;
        
        const n = this.arr.length;
        if (this.i >= n - 1) {
          this._finish();
          return;
        }

        this.highlights[this.j] = '#ff6b6b';
        this.highlights[this.j + 1] = '#ff6b6b';
        
        this.stats.comparisons++;
        this.stats.accesses += 2;
        
        if (this.arr[this.j] > this.arr[this.j + 1]) {
          [this.arr[this.j], this.arr[this.j + 1]] = [this.arr[this.j + 1], this.arr[this.j]];
          this.stats.swaps++;
          this.highlights[this.j] = '#4ecdc4';
          this.highlights[this.j + 1] = '#4ecdc4';
          this.sfx.swap();
        } else {
          this.sfx.compare();
        }

        this.j++;
        if (this.j >= n - 1 - this.i) {
          this.highlights[n - 1 - this.i] = '#45b7d1';
          this.j = 0;
          this.i++;
        }
      }
    }

    class QuickSort extends SortingAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.stack = [[0, this.arr.length - 1]];
        this.pivotIndex = -1;
      }

      step() {
        if (this.finished) return;
        this.stats.steps++;
        
        if (this.stack.length === 0) {
          this._finish();
          return;
        }

        const [low, high] = this.stack.pop();
        if (low < high) {
          const pi = this._partition(low, high);
          this.stack.push([low, pi - 1]);
          this.stack.push([pi + 1, high]);
          this.pivotIndex = pi;
          this.highlights[pi] = '#45b7d1';
          this.sfx.swap();
        } else {
          this.sfx.access();
        }
      }

      _partition(low, high) {
        const pivot = this.arr[high];
        this.highlights[high] = '#ff9ff3';
        let i = low - 1;

        for (let j = low; j < high; j++) {
          this.stats.comparisons++;
          this.stats.accesses += 2;
          this.highlights[j] = '#feca57';
          
          if (this.arr[j] < pivot) {
            i++;
            [this.arr[i], this.arr[j]] = [this.arr[j], this.arr[i]];
            this.stats.swaps++;
            this.highlights[i] = '#48dbfb';
          }
        }
        
        [this.arr[i + 1], this.arr[high]] = [this.arr[high], this.arr[i + 1]];
        this.stats.swaps++;
        return i + 1;
      }
    }

    class MergeSort extends SortingAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.stack = [[0, this.arr.length - 1, 'split']];
        this.temp = new Array(this.arr.length);
      }

      step() {
        if (this.finished) return;
        this.stats.steps++;

        if (this.stack.length === 0) {
          this._finish();
          return;
        }

        const [left, right, action] = this.stack.pop();
        
        if (action === 'split') {
          if (left < right) {
            const mid = Math.floor((left + right) / 2);
            this.stack.push([left, right, 'merge']);
            this.stack.push([mid + 1, right, 'split']);
            this.stack.push([left, mid, 'split']);
            this.sfx.access();
          }
        } else if (action === 'merge') {
          const mid = Math.floor((left + right) / 2);
          this._merge(left, mid, right);
          this.sfx.swap();
        }
      }

      _merge(left, mid, right) {
        let i = left, j = mid + 1, k = left;
        
        for (let x = left; x <= right; x++) {
          this.temp[x] = this.arr[x];
          this.highlights[x] = '#54a0ff';
        }

        while (i <= mid && j <= right) {
          this.stats.comparisons++;
          this.stats.accesses += 2;
          
          if (this.temp[i] <= this.temp[j]) {
            this.arr[k] = this.temp[i];
            this.highlights[k] = '#5f27cd';
            i++;
          } else {
            this.arr[k] = this.temp[j];
            this.highlights[k] = '#ff9ff3';
            j++;
          }
          k++;
        }

        while (i <= mid) {
          this.arr[k] = this.temp[i];
          this.highlights[k] = '#5f27cd';
          i++; k++;
          this.stats.accesses++;
        }

        while (j <= right) {
          this.arr[k] = this.temp[j];
          this.highlights[k] = '#ff9ff3';
          j++; k++;
          this.stats.accesses++;
        }
      }
    }

    class HeapSort extends SortingAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.heapSize = this.arr.length;
        this.phase = 'build';
        this.i = Math.floor(this.arr.length / 2) - 1;
        this.currentHeapify = [];
      }

      step() {
        if (this.finished) return;
        this.stats.steps++;

        if (this.phase === 'build') {
          if (this.i >= 0) {
            this._heapify(this.i);
            this.i--;
            this.sfx.access();
          } else {
            this.phase = 'sort';
            this.i = this.arr.length - 1;
          }
        } else if (this.phase === 'sort') {
          if (this.i > 0) {
            [this.arr[0], this.arr[this.i]] = [this.arr[this.i], this.arr[0]];
            this.stats.swaps++;
            this.highlights[0] = '#ff6b6b';
            this.highlights[this.i] = '#4ecdc4';
            this.heapSize--;
            this._heapify(0);
            this.i--;
            this.sfx.swap();
          } else {
            this._finish();
          }
        }
      }

      _heapify(i) {
        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;

        this.highlights[i] = '#feca57';

        if (left < this.heapSize) {
          this.stats.comparisons++;
          this.stats.accesses += 2;
          this.highlights[left] = '#ff9ff3';
          if (this.arr[left] > this.arr[largest]) largest = left;
        }

        if (right < this.heapSize) {
          this.stats.comparisons++;
          this.stats.accesses += 2;
          this.highlights[right] = '#48dbfb';
          if (this.arr[right] > this.arr[largest]) largest = right;
        }

        if (largest !== i) {
          [this.arr[i], this.arr[largest]] = [this.arr[largest], this.arr[i]];
          this.stats.swaps++;
          this.highlights[largest] = '#5f27cd';
          this._heapify(largest);
        }
      }
    }

    // ========================= Search Algorithms =========================
    class SearchAlgorithm extends Algorithm {
      constructor(canvas, sfx, name) {
        super(canvas, sfx, name);
        this.arr = [];
        this.target = 0;
        this.found = false;
        this.foundIndex = -1;
        this.stats = { comparisons: 0, accesses: 0, steps: 0 };
      }

      init(seed, size) {
        const rng = new SeededRNG(seed);
        this.arr = Array.from({ length: size }, (_, i) => i + 1).sort(() => rng.random() - 0.5);
        this.target = this.arr[rng.int(0, this.arr.length - 1)];
        this.found = false;
        this.foundIndex = -1;
        this.isDone = false;
        this.stats = { comparisons: 0, accesses: 0, steps: 0 };
        this.highlights = {};
      }

      draw() {
        this._clear();
        const { width, height } = this.canvas;
        const n = this.arr.length;
        const barWidth = width / n;
        const maxVal = Math.max(...this.arr, 1);

        // Draw target indicator
        this.ctx.fillStyle = '#ff6b6b';
        this.ctx.font = '16px Arial';
        this.ctx.fillText(`Target: ${this.target}`, 10, 25);

        for (let i = 0; i < n; i++) {
          const barHeight = Math.max(2, (this.arr[i] / maxVal) * (height - 40));
          let color = '#4a4a4a';
          
          if (this.highlights[i]) {
            color = this.highlights[i];
          } else if (this.found && i === this.foundIndex) {
            color = '#00ff00';
          }
          
          this.ctx.fillStyle = color;
          this.ctx.fillRect(i * barWidth + 1, height - barHeight - 10, Math.max(1, barWidth - 2), barHeight);
          
          // Draw value on bar if space allows
          if (barWidth > 15) {
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '10px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(this.arr[i], i * barWidth + barWidth/2, height - 5);
          }
        }
        this.highlights = {};
      }
    }

    class LinearSearch extends SearchAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.currentIndex = 0;
      }

      step() {
        if (this.finished) return;
        this.stats.steps++;

        if (this.currentIndex >= this.arr.length) {
          this._finish();
          return;
        }

        this.highlights[this.currentIndex] = '#feca57';
        this.stats.accesses++;
        this.stats.comparisons++;

        if (this.arr[this.currentIndex] === this.target) {
          this.found = true;
          this.foundIndex = this.currentIndex;
          this.highlights[this.currentIndex] = '#00ff00';
          this.sfx.finish();
          this._finish();
          return;
        }

        this.sfx.compare();
        this.currentIndex++;
      }
    }

    class BinarySearch extends SearchAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.arr.sort((a, b) => a - b); // Binary search needs sorted array
        this.left = 0;
        this.right = this.arr.length - 1;
        this.mid = -1;
      }

      step() {
        if (this.finished) return;
        this.stats.steps++;

        if (this.left > this.right) {
          this._finish();
          return;
        }

        this.mid = Math.floor((this.left + this.right) / 2);
        this.highlights[this.left] = '#ff9ff3';
        this.highlights[this.right] = '#48dbfb';
        this.highlights[this.mid] = '#feca57';

        this.stats.accesses++;
        this.stats.comparisons++;

        if (this.arr[this.mid] === this.target) {
          this.found = true;
          this.foundIndex = this.mid;
          this.highlights[this.mid] = '#00ff00';
          this.sfx.finish();
          this._finish();
          return;
        }

        if (this.arr[this.mid] < this.target) {
          this.left = this.mid + 1;
        } else {
          this.right = this.mid - 1;
        }

        this.sfx.compare();
      }
    }

    // ========================= Graph Algorithms =========================
    class GraphAlgorithm extends Algorithm {
      constructor(canvas, sfx, name) {
        super(canvas, sfx, name);
        this.gridSize = 30;
        this.grid = [];
        this.visited = new Set();
        this.path = new Set();
        this.stats = { nodesVisited: 0, pathLength: 0, steps: 0 };
      }

      init(seed) {
        const rng = new SeededRNG(seed);
        this.grid = Array.from({ length: this.gridSize }, () =>
          Array.from({ length: this.gridSize }, () => ({
            type: rng.random() < 0.25 ? 'wall' : 'empty',
            distance: Infinity,
            visited: false
          }))
        );

        this.start = { x: 1, y: 1 };
        this.goal = { x: this.gridSize - 2, y: this.gridSize - 2 };
        
        // Ensure start and goal are empty
        this.grid[this.start.y][this.start.x].type = 'empty';
        this.grid[this.goal.y][this.goal.x].type = 'empty';
        
        this.visited.clear();
        this.path.clear();
        this.isDone = false;
        this.stats = { nodesVisited: 0, pathLength: 0, steps: 0 };
      }

      draw() {
        this._clear();
        const { width, height } = this.canvas;
        const cellSize = Math.min(width / this.gridSize, height / this.gridSize);

        for (let y = 0; y < this.gridSize; y++) {
          for (let x = 0; x < this.gridSize; x++) {
            const cell = this.grid[y][x];
            const key = `${x},${y}`;
            
            let color = '#2a2a2a';
            if (cell.type === 'wall') color = '#444';
            if (x === this.start.x && y === this.start.y) color = '#00ff00';
            if (x === this.goal.x && y === this.goal.y) color = '#ff0000';
            if (this.path.has(key)) color = '#ffd700';
            if (this.visited.has(key)) color = '#4ecdc4';

            this.ctx.fillStyle = color;
            this.ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);

            // Add glow effect for special cells
            if (this.path.has(key) || (x === this.start.x && y === this.start.y) || (x === this.goal.x && y === this.goal.y)) {
              this.ctx.shadowColor = color;
              this.ctx.shadowBlur = 8;
              this.ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
              this.ctx.shadowBlur = 0;
            }
          }
        }
      }
    }

    class Dijkstra extends GraphAlgorithm {
      init(seed) {
        super.init(seed);
        this.frontier = [{ x: this.start.x, y: this.start.y, dist: 0 }];
        this.cameFrom = new Map();
        this.distances = new Map([[`${this.start.x},${this.start.y}`, 0]]);
      }

      step() {
        if (this.finished || this.frontier.length === 0) {
          if (!this.finished) this._finish();
          return;
        }

        this.stats.steps++;
        this.frontier.sort((a, b) => b.dist - a.dist);
        const current = this.frontier.pop();
        const currentKey = `${current.x},${current.y}`;

        if (this.visited.has(currentKey)) {
          this.sfx.access();
          return;
        }

        this.visited.add(currentKey);
        this.stats.nodesVisited++;
        this.sfx.compare();

        if (current.x === this.goal.x && current.y === this.goal.y) {
          this._reconstructPath();
          this._finish();
          return;
        }

        const neighbors = [[0, 1], [1, 0], [0, -1], [-1, 0]];
        for (const [dx, dy] of neighbors) {
          const nx = current.x + dx;
          const ny = current.y + dy;
          
          if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize && 
              this.grid[ny][nx].type !== 'wall') {
            const neighborKey = `${nx},${ny}`;
            const newDist = current.dist + 1;
            
            if (!this.distances.has(neighborKey) || newDist < this.distances.get(neighborKey)) {
              this.distances.set(neighborKey, newDist);
              this.cameFrom.set(neighborKey, current);
              this.frontier.push({ x: nx, y: ny, dist: newDist });
            }
          }
        }
      }

      _reconstructPath() {
        let currentKey = `${this.goal.x},${this.goal.y}`;
        while (currentKey && this.cameFrom.has(currentKey)) {
          this.path.add(currentKey);
          const prev = this.cameFrom.get(currentKey);
          currentKey = `${prev.x},${prev.y}`;
          this.stats.pathLength++;
        }
      }
    }

    class AStar extends GraphAlgorithm {
      init(seed) {
        super.init(seed);
        this.openSet = [{ x: this.start.x, y: this.start.y, f: 0, g: 0, h: 0 }];
        this.closedSet = new Set();
        this.cameFrom = new Map();
      }

      step() {
        if (this.finished || this.openSet.length === 0) {
          if (!this.finished) this._finish();
          return;
        }

        this.stats.steps++;
        this.openSet.sort((a, b) => b.f - a.f);
        const current = this.openSet.pop();
        const currentKey = `${current.x},${current.y}`;

        this.closedSet.add(currentKey);
        this.visited.add(currentKey);
        this.stats.nodesVisited++;

        if (current.x === this.goal.x && current.y === this.goal.y) {
          this._reconstructPath();
          this._finish();
          return;
        }

        const neighbors = [[0, 1], [1, 0], [0, -1], [-1, 0]];
        for (const [dx, dy] of neighbors) {
          const nx = current.x + dx;
          const ny = current.y + dy;
          const neighborKey = `${nx},${ny}`;

          if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize && 
              this.grid[ny][nx].type !== 'wall' && !this.closedSet.has(neighborKey)) {
            
            const g = current.g + 1;
            const h = Math.abs(nx - this.goal.x) + Math.abs(ny - this.goal.y);
            const f = g + h;

            const existing = this.openSet.find(node => node.x === nx && node.y === ny);
            if (!existing || g < existing.g) {
              if (existing) {
                existing.g = g;
                existing.f = f;
              } else {
                this.openSet.push({ x: nx, y: ny, f, g, h });
              }
              this.cameFrom.set(neighborKey, current);
            }
          }
        }
        this.sfx.access();
      }

      _reconstructPath() {
        let currentKey = `${this.goal.x},${this.goal.y}`;
        while (currentKey && this.cameFrom.has(currentKey)) {
          this.path.add(currentKey);
          const prev = this.cameFrom.get(currentKey);
          currentKey = `${prev.x},${prev.y}`;
          this.stats.pathLength++;
        }
      }
    }

    // ========================= Tree Algorithms =========================
    class TreeNode {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.x = 0;
        this.y = 0;
        this.visited = false;
      }
    }

    class TreeAlgorithm extends Algorithm {
      constructor(canvas, sfx, name) {
        super(canvas, sfx, name);
        this.root = null;
        this.nodes = [];
        this.currentNode = null;
        this.traversalOrder = [];
        this.stats = { nodesVisited: 0, steps: 0 };
      }

      init(seed, size) {
        const rng = new SeededRNG(seed);
        const values = Array.from({ length: Math.min(size, 31) }, () => rng.int(1, 99));
        
        this.root = null;
        this.nodes = [];
        this.traversalOrder = [];
        
        // Build BST
        for (const value of values) {
          this.root = this._insertNode(this.root, value);
        }
        
        this._calculatePositions();
        this.isDone = false;
        this.stats = { nodesVisited: 0, steps: 0 };
      }

      _insertNode(root, value) {
        if (!root) {
          const node = new TreeNode(value);
          this.nodes.push(node);
          return node;
        }
        
        if (value < root.value) {
          root.left = this._insertNode(root.left, value);
        } else if (value > root.value) {
          root.right = this._insertNode(root.right, value);
        }
        return root;
      }

      _calculatePositions() {
        if (!this.root) return;
        
        const levels = [];
        const queue = [{ node: this.root, level: 0, position: 0 }];
        
        while (queue.length > 0) {
          const { node, level, position } = queue.shift();
          
          if (!levels[level]) levels[level] = [];
          levels[level].push({ node, position });
          
          if (node.left) queue.push({ node: node.left, level: level + 1, position: position * 2 });
          if (node.right) queue.push({ node: node.right, level: level + 1, position: position * 2 + 1 });
        }

        const { width, height } = this.canvas;
        const levelHeight = height / (levels.length + 1);
        
        for (let i = 0; i < levels.length; i++) {
          const level = levels[i];
          const levelWidth = width / (Math.pow(2, i) + 1);
          
          level.forEach(({ node, position }, index) => {
            node.x = (position + 1) * levelWidth;
            node.y = (i + 1) * levelHeight;
          });
        }
      }

      draw() {
        this._clear();
        
        // Draw edges first
        this.ctx.strokeStyle = '#666';
        this.ctx.lineWidth = 2;
        this._drawEdges(this.root);
        
        // Draw nodes
        for (const node of this.nodes) {
          let color = '#4a4a4a';
          if (node === this.currentNode) color = '#feca57';
          if (node.visited) color = '#4ecdc4';
          
          this.ctx.fillStyle = color;
          this.ctx.beginPath();
          this.ctx.arc(node.x, node.y, 20, 0, Math.PI * 2);
          this.ctx.fill();
          
          this.ctx.strokeStyle = '#fff';
          this.ctx.stroke();
          
          // Draw value
          this.ctx.fillStyle = '#fff';
          this.ctx.font = '14px Arial';
          this.ctx.textAlign = 'center';
          this.ctx.fillText(node.value, node.x, node.y + 5);
        }
      }

      _drawEdges(node) {
        if (!node) return;
        
        if (node.left) {
          this.ctx.beginPath();
          this.ctx.moveTo(node.x, node.y);
          this.ctx.lineTo(node.left.x, node.left.y);
          this.ctx.stroke();
          this._drawEdges(node.left);
        }
        
        if (node.right) {
          this.ctx.beginPath();
          this.ctx.moveTo(node.x, node.y);
          this.ctx.lineTo(node.right.x, node.right.y);
          this.ctx.stroke();
          this._drawEdges(node.right);
        }
      }
    }

    class InOrderTraversal extends TreeAlgorithm {
      init(seed, size) {
        super.init(seed, size);
        this.stack = [];
        this.currentNode = this.root;
      }

      step() {
        if (this.finished) return;
        this.stats.steps++;

        if (!this.currentNode && this.stack.length === 0) {
          this._finish();
          return;
        }

        if (this.currentNode) {
          this.stack.push(this.currentNode);
          this.currentNode = this.currentNode.left;
          this.sfx.access();
        } else {
          this.currentNode = this.stack.pop();
          this.currentNode.visited = true;
          this.traversalOrder.push(this.currentNode.value);
          this.stats.nodesVisited++;
          this.currentNode = this.currentNode.right;
          this.sfx.compare();
        }
      }
    }

    // ========================= Main Application =========================
    const ALGORITHMS = {
      sorting: {
        'bubble-sort': { name: 'Bubble Sort', class: BubbleSort, desc: 'O(n²) - Simple comparison sort' },
        'quick-sort': { name: 'Quick Sort', class: QuickSort, desc: 'O(n log n) - Divide and conquer' },
        'merge-sort': { name: 'Merge Sort', class: MergeSort, desc: 'O(n log n) - Stable divide and conquer' },
        'heap-sort': { name: 'Heap Sort', class: HeapSort, desc: 'O(n log n) - Selection-based using heap' }
      },
      searching: {
        'linear-search': { name: 'Linear Search', class: LinearSearch, desc: 'O(n) - Sequential search' },
        'binary-search': { name: 'Binary Search', class: BinarySearch, desc: 'O(log n) - Sorted array search' }
      },
      graph: {
        'dijkstra': { name: "Dijkstra's Algorithm", class: Dijkstra, desc: 'Shortest path algorithm' },
        'a-star': { name: 'A* Search', class: AStar, desc: 'Heuristic shortest path' }
      },
      tree: {
        'inorder-traversal': { name: 'In-Order Traversal', class: InOrderTraversal, desc: 'Left-Root-Right traversal' }
      }
    };

    class App {
      constructor() {
        this.dom = {
          category: document.getElementById('categorySelect'),
          algorithm: document.getElementById('algorithmSelect'),
          speed: document.getElementById('speedSlider'),
          size: document.getElementById('sizeSlider'),
          playPause: document.getElementById('playPauseBtn'),
          reset: document.getElementById('resetBtn'),
          battle: document.getElementById('battleModeBtn'),
          canvasA: document.getElementById('canvas'),
          canvasB: document.getElementById('canvasBattle'),
          main: document.querySelector('main'),
          statsA: document.getElementById('statsA'),
          statsB: document.getElementById('statsB'),
          algoInfoA: document.getElementById('algoInfoA'),
          algoInfoB: document.getElementById('algoInfoB')
        };

        this.sfx = new AudioEngine();
        this.simA = null;
        this.simB = null;
        this.isRunning = false;
        this.lastFrameTime = 0;
        this.seed = Date.now();

        this._setupEventListeners();
        this.populateCategories();
        this.updateAlgorithmList();
        this.resetSim();
        this.resizeCanvases();
        
        // Start the main loop
        requestAnimationFrame((t) => this.loop(t));
      }
      
      _setupEventListeners() {
        this.dom.category.addEventListener('change', () => {
          this.updateAlgorithmList();
          this.resetSim();
        });
        
        this.dom.algorithm.addEventListener('change', () => this.resetSim());
        this.dom.size.addEventListener('input', () => this.resetSim());
        this.dom.playPause.addEventListener('click', () => this.togglePlayPause());
        this.dom.reset.addEventListener('click', () => this.resetSim(true));
        this.dom.battle.addEventListener('click', () => this.toggleBattleMode());
        window.addEventListener('resize', () => this.resizeCanvases());
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          switch (e.code) {
            case 'Space':
              e.preventDefault();
              this.togglePlayPause();
              break;
            case 'KeyR':
              e.preventDefault();
              this.resetSim(true);
              break;
            case 'KeyB':
              e.preventDefault();
              this.toggleBattleMode();
              break;
          }
        });
      }
      
      populateCategories() {
        const categoryMap = { 
          sorting: '📊 Sorting', 
          searching: '🔍 Searching',
          graph: '🗺️ Graph', 
          tree: '🌳 Tree'
        };
        
        this.dom.category.innerHTML = Object.keys(ALGORITHMS)
          .map(key => `<option value="${key}">${categoryMap[key]}</option>`)
          .join('');
      }
      
      updateAlgorithmList() {
        const category = this.dom.category.value;
        const list = ALGORITHMS[category];
        this.dom.algorithm.innerHTML = Object.entries(list)
          .map(([id, {name}]) => `<option value="${id}">${name}</option>`)
          .join('');
      }

      resetSim(newSeed = false) {
        this.isRunning = false;
        this.dom.playPause.innerHTML = '▶ Play';
        
        if (newSeed) {
          this.seed = Date.now();
        }
        
        const category = this.dom.category.value;
        const algoId = this.dom.algorithm.value;
        const size = parseInt(this.dom.size.value, 10);
        
        const AlgoClass = ALGORITHMS[category][algoId].class;
        const algoInfo = ALGORITHMS[category][algoId];
        
        this.simA = new AlgoClass(this.dom.canvasA, this.sfx, algoInfo.name);
        this.simA.init(this.seed, size);
        
        // Update algorithm info
        this.dom.algoInfoA.textContent = `${algoInfo.name} - ${algoInfo.desc}`;
        
        if (this.dom.main.classList.contains('battle-mode')) {
          const list = ALGORITHMS[category];
          const algoIds = Object.keys(list);
          const otherAlgoId = algoIds.find(id => id !== algoId) || algoId;
          const OtherAlgoClass = ALGORITHMS[category][otherAlgoId].class;
          const otherAlgoInfo = ALGORITHMS[category][otherAlgoId];
          
          this.simB = new OtherAlgoClass(this.dom.canvasB, this.sfx, otherAlgoInfo.name);
          this.simB.init(this.seed, size);
          this.dom.algoInfoB.textContent = `${otherAlgoInfo.name} - ${otherAlgoInfo.desc}`;
        } else {
          this.simB = null;
        }
        
        this.drawAll();
        this.updateStats();
      }

      togglePlayPause() {
        this.isRunning = !this.isRunning;
        this.dom.playPause.innerHTML = this.isRunning ? '⏸ Pause' : '▶ Play';
      }

      toggleBattleMode() {
        this.dom.main.classList.toggle('battle-mode');
        this.dom.battle.innerHTML = this.dom.main.classList.contains('battle-mode') ? '👁️ Single Mode' : '⚔ Battle Mode';
        this.resizeCanvases();
        this.resetSim();
      }
      
      loop(timestamp) {
        const elapsed = timestamp - this.lastFrameTime;
        const speed = parseFloat(this.dom.speed.value);
        const stepDelay = Math.max(10, 200 - (speed * 35));

        if (this.isRunning && elapsed >= stepDelay) {
          this.lastFrameTime = timestamp;

          let stepped = false;
          if (this.simA && !this.simA.finished) {
            this.simA.step();
            stepped = true;
          }
          
          if (this.simB && !this.simB.finished) {
            this.simB.step();
            stepped = true;
          }

          if (stepped) {
            this.drawAll();
            this.updateStats();
          }
          
          const allFinished = (!this.simA || this.simA.finished) && (!this.simB || this.simB.finished);
          if (allFinished) {
            this.isRunning = false;
            this.dom.playPause.innerHTML = '▶ Play';
          }
        }
        
        requestAnimationFrame((t) => this.loop(t));
      }
      
      drawAll() {
        if (this.simA) this.simA.draw();
        if (this.simB) this.simB.draw();
      }
      
      updateStats() {
        if (this.simA) {
          this.dom.statsA.innerHTML = Object.entries(this.simA.stats)
            .map(([key, value]) => `<div>${key}: ${value}</div>`)
            .join('');
        }
        
        if (this.simB) {
          this.dom.statsB.innerHTML = Object.entries(this.simB.stats)
            .map(([key, value]) => `<div>${key}: ${value}</div>`)
            .join('');
        }
      }
      
      resizeCanvases() {
        const dpr = window.devicePixelRatio || 1;
        
        for (const canvas of [this.dom.canvasA, this.dom.canvasB]) {
          const container = canvas.parentElement;
          const rect = container.getBoundingClientRect();
          
          canvas.width = rect.width * dpr;
          canvas.height = rect.height * dpr;
          
          const ctx = canvas.getContext('2d');
          ctx.scale(dpr, dpr);
          
          canvas.style.width = rect.width + 'px';
          canvas.style.height = rect.height + 'px';
        }
        
        // Recalculate positions for tree algorithms
        if (this.simA && this.simA._calculatePositions) {
          this.simA._calculatePositions();
        }
        if (this.simB && this.simB._calculatePositions) {
          this.simB._calculatePositions();
        }
        
        this.drawAll();
      }
    }

    // Initialize the application when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      new App();
    });
  </script>
</body>
</html>